/**
* @File hash_table.c
* CS 470 Assignment 2
* Ray Imber
* Implements a very simple hash table that uses c strings as keys
* Uses function pointers and void pointers for all element level functionality so that we can use what ever data structure we want for the individual elements
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//function pointers to allow us to use an arbitrary datastructure at the element level.
typedef void (*free_hash_element_function)(void*);
typedef void (*init_hash_element_function)(void**);
typedef void (*add_hash_element_function)(void**, void*);
typedef void (*remove_hash_element_function)(void**, void*);

typedef struct
{
  int size;
  free_hash_element_function free_element;
  init_hash_element_function initialize_element;
  add_hash_element_function add_element;
  remove_hash_element_function remove_element;
  void **table; //arry of pointers to anything
} hashTable;

/**
* Creates a new Hash Table
* @param table_size the max number of elements in the hash table
* @param free_function a function pointer to a function to free the memory used by a single element in the hash table.
* @param create_function a function pointer to a function to initialize an empty data structure to be placed in the hash
* @param add_function a function pointer to a function that adds an element to a data structure pointed to by a single hash element.
* @param remove_function a function pointer to a function that removes an element from a data structure pointed to by a single hash element.
* @return a pointer to a valid hashTable struct for use with the other hashTable functions or NULL on error.
*/
hashTable* hashTable_create(int table_size, free_hash_element_function free_function, init_hash_element_function init_function, add_hash_element_function add_function, remove_hash_element_function remove_function)
{
  if(table_size < 1) { return NULL; }
  hashTable *newTable;

  //allocate memory for the struct
  newTable = malloc(sizeof(hashTable));
  if(newTable == NULL) { printf("Error allocating memory for hashTable"); exit(1); }

  //allocate memory for the table
  newTable->table = malloc(sizeof(void*) * table_size);
  if(newTable->table == NULL) { printf("Error allocating memory for hashTable"); exit(1); }

  //init the hashTable data structure
  newTable->size = table_size;
  newTable->free_element = free_function;
  newTable->initialize_element = init_function;
  newTable->add_element = add_function;
  newTable->remove_element = remove_function;

  //init the elements of the table
  int i;
  for(i=0; i < table_size; i++) {
   newTable->initialize_element( (&newTable->table[i]) );
  }

  return newTable;
}

/**
* Cleans up a hashTable data structure
* @param cur_hashTable A pointer to the hashTable to be destroyed
*/
void hashTable_free(hashTable* cur_hashTable)
{
  // Clean up each individual element
  int i;
  for (i = 0; i < cur_hashTable->size; ++i)
  {
    if(cur_hashTable->table[i] != NULL)
    {
      cur_hashTable->free_element(cur_hashTable->table[i]);
    }
  }

  // Clean up the struct itself
  free(cur_hashTable->table);
  free(cur_hashTable);
}

/**
* Generates the hash of the key
* @param cur_hashTable a hashTable struct
* @param key a c string to use as a key
* @return an index into the hashTable struct
*/
unsigned int hashTable_hash(hashTable* cur_hashTable, char* key)
{
  // sdbm Algorithm.
  unsigned int hashAddress = 0;
  unsigned int i;
  for (i=0; key[i]!='\0'; i++){
    hashAddress = key[i] + (hashAddress << 6) + (hashAddress << 16) - hashAddress;
  }
  // Make sure that our address is within the range of the actual hash table size.
  hashAddress = hashAddress % cur_hashTable->size;
  return hashAddress;
}

/**
* Add an element to the hashTable
* @param cur_hashTable a hashTable struct
* @param key a c string to used to generate the current hash position.
* @param value a pointer to the datastructure to be insterted into the hash table at the position generated by the key.
*/
void hashTable_addElement(hashTable* cur_hashTable, char* key, void* value)
{
  unsigned int hash = hashTable_hash(cur_hashTable, key);
  cur_hashTable->add_element(&(cur_hashTable->table[hash]), value);
}

/**
* Remove an element from the hashTable
* @param cur_hashTable a hashTable struct
* @param key a c string used to generate the current hash position.
* @param value a specific value to remove from the data structure at the current hash. Useful for linked list type datastructure or other collision handling schemes.
*/
void hashTable_removeElement(hashTable* cur_hashTable, char* key, void* value)
{
  unsigned int hash = hashTable_hash(cur_hashTable, key);
  cur_hashTable->remove_element(&(cur_hashTable->table[hash]), value);
}

/**
* Looks up a value in the hash table at the current hash.
* @param cur_hashTable a hashTable struct
* @param key a c string used to generate the current hash position.
* @return a void pointer to the element at the hash for the input key, or a NULL pointer if no element exists at this position.
*/
void* hashTable_lookup(hashTable* cur_hashTable, char* key)
{
  unsigned int hash = hashTable_hash(cur_hashTable, key);
  return cur_hashTable->table[hash];
}